"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[93912],{99111:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>l,contentTitle:()=>t,default:()=>h,frontMatter:()=>r,metadata:()=>a,toc:()=>d});var s=i(74848),o=i(28453);const r={sidebar_position:3},t="Authorization",a={id:"docs/authorization",title:"Authorization",description:"GraphGlue only provides Authorization features. Authentication must be implemented by the user, for example using OpenID Connect",source:"@site/docs/docs/authorization.mdx",sourceDirName:"docs",slug:"/docs/authorization",permalink:"/docs/authorization",draft:!1,unlisted:!1,tags:[],version:"current",sidebarPosition:3,frontMatter:{sidebar_position:3},sidebar:"docSidebar",previous:{title:"Modeling",permalink:"/docs/modeling"},next:{title:"Connections",permalink:"/docs/connections"}},l={},d=[{value:"Declaration",id:"declaration",level:2},{value:"Overview",id:"overview",level:3},{value:"Rule",id:"rule",level:3},{value:"Inheritance",id:"inheritance",level:3},{value:"Checking",id:"checking",level:2},{value:"Permission",id:"permission",level:3},{value:"GraphQL",id:"graphql",level:3},{value:"Manually",id:"manually",level:3}];function c(e){const n={a:"a",admonition:"admonition",br:"br",code:"code",h1:"h1",h2:"h2",h3:"h3",li:"li",ol:"ol",p:"p",pre:"pre",ul:"ul",...(0,o.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.h1,{id:"authorization",children:"Authorization"}),"\n",(0,s.jsx)(n.admonition,{type:"caution",children:(0,s.jsx)(n.p,{children:"GraphGlue only provides Authorization features. Authentication must be implemented by the user, for example using OpenID Connect"})}),"\n",(0,s.jsx)(n.h2,{id:"declaration",children:"Declaration"}),"\n",(0,s.jsxs)(n.p,{children:["To declare Permissions, GraphGlue uses a declarative approach, meaning authorizations are declared using the ",(0,s.jsx)(n.code,{children:"@Authorization"})," annotation on ",(0,s.jsx)(n.code,{children:"Node"})," subtypes.\nCurrently, only node-level permissions are supported, while field-level permissions are not.\nHowever, if you need field-level permissions, ",(0,s.jsx)(n.a,{href:"#manually",children:"checking manually"})," is possible."]}),"\n",(0,s.jsx)(n.h3,{id:"overview",children:"Overview"}),"\n",(0,s.jsxs)(n.p,{children:["Continuing the sample domain model introduced in ",(0,s.jsx)(n.a,{href:"./modeling#overview",children:"Modeling"}),", declaraing a permission looks like this:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-kotlin",children:'@DomainNode\n@Authorization(\n    name = "READ",\n    allow = [Rule("actorAllowedBean")],\n    allowFromRelated = ["movies"],\n    disallow = [Rule("actorDisallowedBean")]\n)\nclass Actor : Node() {\n    @NodeRelationship("ACTOR", Direction.INCOMING)\n    val movies by NodeProperty<Movie>()\n}\n'})}),"\n",(0,s.jsxs)(n.p,{children:["The ",(0,s.jsx)(n.code,{children:"name"})," is used to identify the permission to check, it is later referenced in ",(0,s.jsx)(n.a,{href:"#checking",children:"Checking"}),"."]}),"\n",(0,s.jsx)(n.p,{children:"The checking algorithm works in two steps:"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:["Check if access is allowed. Access is allowed if any ",(0,s.jsx)(n.code,{children:"Rule"})," in ",(0,s.jsx)(n.code,{children:"allow"})," evaluates to ",(0,s.jsx)(n.code,{children:"true"}),", OR if the permission with ",(0,s.jsx)(n.code,{children:"name"})," is granted to any node referenced in ",(0,s.jsx)(n.code,{children:"allowFromRelated"}),", or if ",(0,s.jsx)(n.code,{children:"allowAll"})," is ",(0,s.jsx)(n.code,{children:"true"}),".\nIf neither of these conditions is fulfilled, the permission is NOT granted.\nEspecially, if ",(0,s.jsx)(n.code,{children:"allow"})," and ",(0,s.jsx)(n.code,{children:"allowFromRelated"})," are both empty, allow is not granted."]}),"\n",(0,s.jsx)(n.admonition,{type:"caution",children:(0,s.jsxs)(n.p,{children:["If any ",(0,s.jsx)(n.code,{children:"NodeSetProperty"})," is referenced in ",(0,s.jsx)(n.code,{children:"allowFromRelated"}),", allow is granted if the permission is granted to ANY of the related nodes."]})}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:["Check if access is disallowed. Access is granted if an only if NO ",(0,s.jsx)(n.code,{children:"Rule"})," in ",(0,s.jsx)(n.code,{children:"disallow"})," evaluates to ",(0,s.jsx)(n.code,{children:"true"}),"."]}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["In this example, allow is granted if the ",(0,s.jsx)(n.code,{children:'"actorAllowedBean"'})," Rule evaluate to ",(0,s.jsx)(n.code,{children:"true"}),", OR if ",(0,s.jsx)(n.code,{children:'"READ"'})," is granted to any Movie in ",(0,s.jsx)(n.code,{children:"movies"}),".\nThen, the permission is granted if also ",(0,s.jsx)(n.code,{children:'"actorDisallowedBean"'})," evaluates to ",(0,s.jsx)(n.code,{children:"false"})]}),"\n",(0,s.jsx)(n.h3,{id:"rule",children:"Rule"}),"\n",(0,s.jsxs)(n.p,{children:["A ",(0,s.jsx)(n.code,{children:"Rule"})," consists of two parts: a ",(0,s.jsx)(n.code,{children:"String"})," that references a Spring bean of type ",(0,s.jsx)(n.code,{children:"AllowRuleGenerator"}),"/",(0,s.jsx)(n.code,{children:"DisllowRuleGenerator"}),", and a list of Strings used as configuration parameters."]}),"\n",(0,s.jsx)(n.p,{children:"Example:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-kotlin",children:'@Bean("startsWithRule")\nfun startsWithRuleGenerator(): DisallowRuleGenerator {\n    return DisallowRuleGenerator { node, rule, permission ->\n        val requiredPrefix = (permission.context as MyAuthorizationContext).prefix\n        node.property(rule.options[0]).startsWith(Cypher.anonParameter(requiredPrefix))\n    }\n}\n'})}),"\n",(0,s.jsxs)(n.p,{children:["This rule checks if a String property on ",(0,s.jsx)(n.code,{children:"node"})," with a name provided as first configuration parameter has NOT a prefix provided in the permission to check.\nIt can be used like this:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-kotlin",children:'@DomainNode\n@Authorization("READ", disallow = [Rule("startsWithRule", "name")])\nclass NamedNode(val name: String) : Node()\n'})}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"AllowRuleGenerator"})," works the same, with the difference that it may return an additional ",(0,s.jsx)(n.code,{children:"RelationshipPattern"})," that is checked for existance in combination with the returned condition."]}),"\n",(0,s.jsxs)(n.p,{children:["Note that the ",(0,s.jsx)(n.code,{children:"AllowRuleGenerator"}),"/",(0,s.jsx)(n.code,{children:"DisllowRuleGenerator"})," generates a ",(0,s.jsx)(n.a,{href:"https://neo4j-contrib.github.io/cypher-dsl/current/",children:"CypherDSL"})," ",(0,s.jsx)(n.code,{children:"Conditon"}),", which allows checking complex conditions directly in the database."]}),"\n",(0,s.jsx)(n.admonition,{type:"caution",children:(0,s.jsxs)(n.p,{children:["Since version 6.0.0, disallow rules affect only the path from the node to the node to check the permission on.\nBefore, disallow rules affect all nodes in the ",(0,s.jsx)(n.code,{children:"RelationshipPattern"})," generated by the allow rule."]})}),"\n",(0,s.jsx)(n.h3,{id:"inheritance",children:"Inheritance"}),"\n",(0,s.jsxs)(n.p,{children:["The algorithm first searches for all ",(0,s.jsx)(n.code,{children:"@Authorization"})," annotations with the specified ",(0,s.jsx)(n.code,{children:"name"}),".\nThis includes annotations from superclasses.\nIt is even possible to use multiple ",(0,s.jsx)(n.code,{children:"@Authorization"})," annotations with the same ",(0,s.jsx)(n.code,{children:"name"})," on the same class, although this is not recommended."]}),"\n",(0,s.jsx)(n.h2,{id:"checking",children:"Checking"}),"\n",(0,s.jsx)(n.h3,{id:"permission",children:"Permission"}),"\n",(0,s.jsxs)(n.p,{children:["Generally, it is checked if a ",(0,s.jsx)(n.code,{children:"Permission"})," is granted to a ",(0,s.jsx)(n.code,{children:"Node"})]}),"\n",(0,s.jsxs)(n.p,{children:["A ",(0,s.jsx)(n.code,{children:"Permission"})," consists of two parts"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"The name of the permission to be checked"}),"\n",(0,s.jsxs)(n.li,{children:["A ",(0,s.jsx)(n.code,{children:"AuthorizationContext"})," instance. It is intended implement this interface in order to provide custom values to ",(0,s.jsx)(n.code,{children:"AuthorizationRuleGenerator"})," instances, e.g. the id of the authenticated user, or a role String."]}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"graphql",children:"GraphQL"}),"\n",(0,s.jsxs)(n.p,{children:["To automatically check permissions, provide a ",(0,s.jsx)(n.code,{children:"Permission"})," to the ",(0,s.jsx)(n.a,{href:"https://opensource.expediagroup.com/graphql-kotlin/docs/server/spring-server/spring-graphql-context",children:"GraphQL Context Map"})," under the key ",(0,s.jsx)(n.code,{children:"Permission::class"}),"."]}),"\n",(0,s.jsx)(n.p,{children:"Permissions are checked at"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["the ",(0,s.jsx)(n.code,{children:"node"})," query"]}),"\n",(0,s.jsxs)(n.li,{children:["queries generated using the ",(0,s.jsx)(n.code,{children:"name"})," parameter of the ",(0,s.jsx)(n.code,{children:"@DomainNode"})," annotation"]}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"./modeling#graphglue-relationships",children:"GraphGlue relationship properties"})}),"\n"]}),"\n",(0,s.jsxs)(n.admonition,{type:"warning",children:[(0,s.jsxs)(n.p,{children:["Any other properties returning ",(0,s.jsx)(n.code,{children:"Node"})," types are NOT automatically checked!\nThis is due to checking is only done directly in the database.\nThis is espacially the case when returning nodes from functions which use the lazy-loading functionality of GraphGlue relationships, or when returning nodes in mutations."]}),(0,s.jsxs)(n.p,{children:["Consider the following example with the ",(0,s.jsx)(n.code,{children:"Actor"})," class from ",(0,s.jsx)(n.a,{href:"#overview",children:"above"})]}),(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-kotlin",children:"data class CreateActorOutput(val actor: Actor)\n"})}),(0,s.jsxs)(n.p,{children:["When returing this, ",(0,s.jsx)(n.code,{children:"actor"})," is NOT checked, however, note that the permission is checked for GraphGlue relationships on ",(0,s.jsx)(n.code,{children:"actor"}),", in this example the ",(0,s.jsx)(n.code,{children:"movies"})," property."]})]}),"\n",(0,s.jsx)(n.admonition,{type:"info",children:(0,s.jsxs)(n.p,{children:["Permissions are only checked if necessary.\nConsidering the ",(0,s.jsx)(n.a,{href:"#overview",children:"above"}),", if ",(0,s.jsx)(n.code,{children:"actors"})," is accessed on ",(0,s.jsx)(n.code,{children:"Movie"}),", allow is not checked as ",(0,s.jsx)(n.code,{children:"Actor"})," allows from related ",(0,s.jsx)(n.code,{children:"movies"}),"."]})}),"\n",(0,s.jsx)(n.h3,{id:"manually",children:"Manually"}),"\n",(0,s.jsxs)(n.p,{children:["Permissions can be manually checked by injecting a ",(0,s.jsx)(n.code,{children:"AuthorizationChecker"})," bean.\nIt provides a ",(0,s.jsx)(n.code,{children:"hasAuthorization"})," function, which takes a ",(0,s.jsx)(n.code,{children:"Node"})," and a ",(0,s.jsx)(n.code,{children:"Permission"})," as input, and returns whether the permission is granted on the node."]}),"\n",(0,s.jsxs)(n.p,{children:["While it is up to the user to provide the required ",(0,s.jsx)(n.code,{children:"Permission"}),", the recommended way is to put it into the GraphQL Context Map as described in ",(0,s.jsx)(n.a,{href:"#graphql",children:"GraphQL"}),", and then obtain it using an ",(0,s.jsx)(n.a,{href:"https://opensource.expediagroup.com/graphql-kotlin/docs/schema-generator/execution/data-fetching-environment/",children:"injected DataFetchingEnvironment"}),".",(0,s.jsx)(n.br,{}),"\n","Example:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-kotlin",children:'@Component\nclass LeafMutations: Mutation {\n    fun createLeaf(input: CreateLeafInput, dfe: DataFetchingEnvironment): CreateLeafOutput {\n        val readPermission = dfe.requiredPermission // gives access to the permission under the key Permission::class\n        val myPermission = Permission("WRITE", dfe.authorizationContext) // AuthorizationContext from the Permission\n        // ...\n    }\n}\n'})}),"\n",(0,s.jsx)(n.admonition,{type:"tip",children:(0,s.jsxs)(n.p,{children:["If automatic permission checking in GraphQL is not wanted, it is also possible to only provide the ",(0,s.jsx)(n.code,{children:"AuthorizationContext"})," under the key ",(0,s.jsx)(n.code,{children:"AuthorizationContext::class"})," to the GraphQL Context Map"]})})]})}function h(e={}){const{wrapper:n}={...(0,o.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(c,{...e})}):c(e)}}}]);